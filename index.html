<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choufli Hal Chess</title>
    <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Choufli Hal Chess</title>

  <!-- Open Graph (Facebook / WhatsApp / LinkedIn) -->
  <meta property="og:title" content="Choufli Hal Chess">
  <meta property="og:description" content="Play Choufli Hal Chess ‚Äî a fun themed chess game.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://yassino14.github.io/Choufli-Hal-Chess/">
  <meta property="og:image" content="https://yassino14.github.io/Choufli-Hal-Chess/cover.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="Choufli Hal Chess cover">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Choufli Hal Chess">
  <meta name="twitter:description" content="Play Choufli Hal Chess ‚Äî a fun themed chess game.">
  <meta name="twitter:image" content="https://yassino14.github.io/Choufli-Hal-Chess/cover.png">

  <!-- favicon (optional) -->
  <link rel="icon" href="https://yassino14.github.io/Choufli-Hal-Chess/favicon.ico" type="image/x-icon">
</head>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Changa:wght@400;700&display=swap');
        body {
            font-family: 'Changa', sans-serif;
            color: #4a4a4a;
            background-image: url(cover.png);      
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 40vw;
            height: 40vw;
            max-width: 640px;
            max-height: 640px;
            border: 10px solid #8b5e34;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), 0 6px 6px rgba(0,0,0,0.25);
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }

        .square img {
            width: 90%;
            height: 90%;
            object-fit: cover;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.25);
            transition: transform 150ms ease, filter 150ms ease;
        }
        .square img:hover {
            transform: scale(1.05);
        }
        .selected {
            background-color: #6a994e !important;
        }
        .in-check {
            background-color: #ef4444 !important; /* Red for check */
        }
        .valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35%;
            height: 35%;
            background-color: rgba(106, 153, 78, 0.7);
            border-radius: 50%;
            pointer-events: none;
        }
        .capture-move::after {
             background-color: rgba(200, 78, 78, 0.7);
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fdfaf6;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-content h2 {
            font-size: 2rem;
            margin-bottom: 20px;
        }
        .modal-content button {
            background-color: #8b5e34;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-content button:hover {
            background-color: #6a994e;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div id="startModal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-3xl font-bold">Welcome to Choufli Hal Chess!</h2>
            <p class="my-4">Click the button to start the game</p>
            <button id="startGameButton" class="text-xl">Start Game</button>
        </div>
    </div>
    
    <audio id="backgroundMusic" loop>
        <source src="music.mp3" type="audio/mpeg">
    </audio>

    <h1 class="text-4xl md:text-5xl font-bold text-center mb-4 text-[#C7C4B9]">‚ôüÔ∏è Choufli Hal Chess ‚ôüÔ∏è</h1>

    <div id="game-info" class="game-info mb-4 text-[#C7C4B9]">White's Turn</div>

    <div class="chessboard" id="board"></div>
    
    <div class="flex space-x-4 mt-6">
        <button id="resetButton" class="px-6 py-3 bg-[#8b5e34] text-white font-bold rounded-lg shadow-md hover:bg-[#6a994e] transition-colors duration-300">New Game</button>
        <button id="undoButton" class="px-6 py-3 bg-[#4a5568] text-white font-bold rounded-lg shadow-md hover:bg-[#2d3748] transition-colors duration-300" disabled>Undo Move</button>
        <button id="musicToggleButton" class="px-4 py-3 bg-gray-500 text-white font-bold rounded-lg shadow-md hover:bg-gray-600 transition-colors duration-300">üéµ Mute</button>
    </div>

    <div id="gameOverModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="gameOverMessage"></h2>
            <button id="playAgainButton">Play Again</button>
        </div>
    </div>


<script>
    // --- MODEL: DATA AND GAME LOGIC ---
    const boardElement = document.getElementById("board");
    const gameInfoElement = document.getElementById("game-info");
    const resetButton = document.getElementById("resetButton");
    const undoButton = document.getElementById("undoButton");
    const gameOverModal = document.getElementById("gameOverModal");
    const gameOverMessage = document.getElementById("gameOverMessage");
    const playAgainButton = document.getElementById("playAgainButton");
    const startModal = document.getElementById("startModal");
    const startGameButton = document.getElementById("startGameButton");
    const musicToggleButton = document.getElementById("musicToggleButton");
    const backgroundMusic = document.getElementById("backgroundMusic");

    const images = {
        Slimane: "images/slimane.jpg", Zeineb: "images/zaineb.jpg", Janet: "images/janet.jpg", "B√©ji Matrix": "images/beji.jpg", Fadhila: "images/fadhila.png", Douja: "images/douja.jpg", Sboui: "images/sbou3i.jpeg", Fouchika: "images/fouchika.jpg", Azza: "images/azza.png", Amani: "images/amani.jpg", Fatma: "images/fatma.jpg", Dalenda: "images/dalenda.jpeg", Kalthoum: "images/kalthoum.jpg", Chabrouch: "images/chabrouch.png", Ta√Øeb: "images/taieb.jpeg", Houssi: "images/houssi.jpg",
    };

    const PIECE_TYPES = { K: 'king', Q: 'queen', R: 'rook', B: 'bishop', N: 'knight', P: 'pawn' };
    const TEAMS = { W: 'white', B: 'black' };

    let boardState = [];
    let selectedPiece = null;
    let currentPlayer = TEAMS.W;
    let validMoves = [];
    let moveHistory = [];
    let enPassantTarget = null; // For en passant
    let isGameOver = false;

    // --- MUSIC CONTROL ---
    function startMusic() {
        backgroundMusic.play().catch(e => console.error("Audio autoplay was blocked.", e));
    }

    function toggleMusic() {
        backgroundMusic.muted = !backgroundMusic.muted;
        musicToggleButton.textContent = backgroundMusic.muted ? 'üîá Unmute' : 'üéµ Mute';
    }

    // --- INITIALIZATION ---
    function initializeBoard() {
        const initialSetup = [
            ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
            ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
            ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
        ];

        boardState = initialSetup.map((row, r) =>
            row.map((pieceCode, c) => {
                if (!pieceCode) return null;
                const team = pieceCode.charAt(0) === 'w' ? TEAMS.W : TEAMS.B;
                const type = PIECE_TYPES[pieceCode.charAt(1)];
                return { team, type, name: getPieceName(team, type, r, c), row: r, col: c, hasMoved: false };
            })
        );
        moveHistory = [];
        enPassantTarget = null;
        isGameOver = false;
        updateUndoButton();
    }

    function getPieceName(team, type, row, col) {
        const whitePieces = { king: "Slimane", queen: "Zeineb", rook: ["Janet", "B√©ji Matrix"], bishop: ["Fadhila", "Douja"], knight: ["Sboui", "Fouchika"], pawn: ["Azza", "Amani", "Fatma", "Dalenda", "Kalthoum", "Chabrouch", "Ta√Øeb", "Houssi"] };
        const blackPieces = { king: "Slimane", queen: "Zeineb", rook: ["Janet", "B√©ji Matrix"], bishop: ["Fadhila", "Douja"], knight: ["Sboui", "Fouchika"], pawn: ["Azza", "Amani", "Fatma", "Dalenda", "Kalthoum", "Chabrouch", "Ta√Øeb", "Houssi"] };
        const p = team === TEAMS.W ? whitePieces : blackPieces;
        
        if (type === 'pawn') return p.pawn[col];
        if (type === 'rook') return p.rook[col === 0 ? 0 : 1];
        if (type === 'knight') return p.knight[col === 1 ? 0 : 1];
        if (type === 'bishop') return p.bishop[col === 2 ? 0 : 1];
        if (type === 'queen') return p.queen;
        if (type === 'king') return p.king;
        return "";
    }

    // --- VIEW: RENDERING THE BOARD ---
    function renderBoard() {
        boardElement.innerHTML = "";
        const king = findKing(currentPlayer);
        const kingInCheck = king ? isSquareAttacked(king.row, king.col, getOpponent(currentPlayer)) : false;

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement("div");
                const isLight = (row + col) % 2 === 0;
                square.className = `square ${isLight ? "light" : "dark"}`;
                square.dataset.row = row;
                square.dataset.col = col;

                const piece = boardState[row][col];
                if (piece) {
                    if (piece.type === 'king' && piece.team === currentPlayer && kingInCheck) {
                        square.classList.add('in-check');
                    }
                    const img = document.createElement("img");
                    img.src = images[piece.name] || "images/placeholder.png";
                    img.alt = `${piece.team} ${piece.type}`;
                    img.onerror = function() {
                        this.onerror=null;
                        this.src=`https://placehold.co/100x100/${piece.team === 'white' ? 'FFF/000' : '000/FFF'}?text=${piece.name.substring(0,1)}`;
                    };
                    img.dataset.piece = true;
                    square.appendChild(img);
                }
                boardElement.appendChild(square);
            }
        }
        updateHighlights();
    }
    
    function updateHighlights() {
        document.querySelectorAll('.square.selected').forEach(s => s.classList.remove('selected'));
        document.querySelectorAll('.valid-move').forEach(s => s.classList.remove('valid-move', 'capture-move'));

        if (selectedPiece) {
            const square = document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col}']`);
            if (square) square.classList.add('selected');
        }
        validMoves.forEach(move => {
            const square = document.querySelector(`[data-row='${move.row}'][data-col='${move.col}']`);
            if (square) {
                square.classList.add('valid-move');
                if (boardState[move.row][move.col] || (move.isEnPassant)) square.classList.add('capture-move');
            }
        });
    }

    function updateUndoButton() {
        undoButton.disabled = moveHistory.length === 0 || isGameOver;
    }

    // --- CONTROLLER: HANDLING USER INPUT ---
    boardElement.addEventListener("click", (event) => {
        if (isGameOver) return;
        const square = event.target.closest(".square");
        if (!square) return;

        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        const piece = boardState[row][col];

        if (selectedPiece) {
            const move = validMoves.find(m => m.row === row && m.col === col);
            if (move) {
                movePiece(selectedPiece, move);
            } else {
                deselectPiece();
                if (piece && piece.team === currentPlayer) selectPiece(piece);
            }
        } else if (piece && piece.team === currentPlayer) {
            selectPiece(piece);
        }
    });

    function selectPiece(piece) {
        selectedPiece = piece;
        validMoves = getLegalMoves(piece);
        updateHighlights();
    }

    function deselectPiece() {
        selectedPiece = null;
        validMoves = [];
        updateHighlights();
    }

    function movePiece(piece, move) {
        moveHistory.push({
            board: JSON.parse(JSON.stringify(boardState)),
            player: currentPlayer,
            enPassant: enPassantTarget
        });
        updateUndoButton();
        
        const { row: fromRow, col: fromCol } = piece;
        const { row: toRow, col: toCol } = move;

        // En Passant capture
        if (move.isEnPassant) {
            boardState[fromRow][toCol] = null;
        }
        
        // Castling
        if (move.isCastle) {
            const rookFromCol = toCol > fromCol ? 7 : 0;
            const rookToCol = toCol > fromCol ? 5 : 3;
            const rook = boardState[fromRow][rookFromCol];
            boardState[fromRow][rookToCol] = { ...rook, col: rookToCol, hasMoved: true };
            boardState[fromRow][rookFromCol] = null;
        }

        // Update piece position
        boardState[toRow][toCol] = { ...piece, row: toRow, col: toCol, hasMoved: true };
        boardState[fromRow][fromCol] = null;
        
        // Pawn Promotion
        if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
            boardState[toRow][toCol].type = 'queen';
            boardState[toRow][toCol].name = piece.team === 'white' ? 'Zeineb' : 'Hayet';
        }

        // Set en passant target for next turn
        if (piece.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
            enPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
        } else {
            enPassantTarget = null;
        }

        switchPlayer();
        deselectPiece();
        renderBoard();
        checkGameState();
    }
    
    function undoMove() {
        if (moveHistory.length === 0) return;
        const lastState = moveHistory.pop();
        boardState = lastState.board;
        currentPlayer = lastState.player;
        enPassantTarget = lastState.enPassant;
        isGameOver = false;
        deselectPiece();
        renderBoard();
        updatePlayerInfo();
        updateUndoButton();
    }

    function switchPlayer() {
        currentPlayer = getOpponent(currentPlayer);
        updatePlayerInfo();
    }
    
    function updatePlayerInfo() {
        if (isGameOver) return;
        const teamName = currentPlayer === TEAMS.W ? "White Team" : "Black Team";
        gameInfoElement.textContent = `${currentPlayer === TEAMS.W ? 'White' : 'Black'}'s Turn (${teamName})`;
    }

    // --- GAME LOGIC: RULES, MOVES & GAME STATE ---
    function getLegalMoves(piece) {
        const pseudoLegalMoves = getPseudoLegalMoves(piece);
        return pseudoLegalMoves.filter(move => {
            // Simulate the move
            const fromRow = piece.row;
            const fromCol = piece.col;
            const toRow = move.row;
            const toCol = move.col;
            const originalPiece = boardState[toRow][toCol];
            
            boardState[toRow][toCol] = { ...piece, row: toRow, col: toCol };
            boardState[fromRow][fromCol] = null;

            // Check if the king is safe after the move
            const king = findKing(piece.team);
            const isLegal = !isSquareAttacked(king.row, king.col, getOpponent(piece.team));

            // Revert the move
            boardState[fromRow][fromCol] = piece;
            boardState[toRow][toCol] = originalPiece;

            return isLegal;
        });
    }

    function getPseudoLegalMoves(piece) {
        const moves = [];
        const { row, col, type, team } = piece;

        const addMove = (r, c) => {
            if (r < 0 || r > 7 || c < 0 || c > 7) return false;
            const target = boardState[r][c];
            if (!target) {
                moves.push({ row: r, col: c });
                return true;
            }
            if (target.team !== team) {
                moves.push({ row: r, col: c });
            }
            return false;
        };
        
        const addSlidingMoves = (directions) => {
            directions.forEach(([dr, dc]) => {
                let r = row + dr, c = col + dc;
                while (addMove(r, c)) { r += dr; c += dc; }
            });
        };

        switch (type) {
            case 'pawn':
                const dir = team === TEAMS.W ? -1 : 1;
                const startRow = team === TEAMS.W ? 6 : 1;
                if (row + dir >= 0 && row + dir < 8 && !boardState[row + dir][col]) {
                    moves.push({ row: row + dir, col: col });
                    if (row === startRow && !boardState[row + 2 * dir][col]) {
                        moves.push({ row: row + 2 * dir, col: col });
                    }
                }
                [-1, 1].forEach(dc => {
                    if (col + dc >= 0 && col + dc < 8 && row + dir >= 0 && row + dir < 8) {
                        const target = boardState[row + dir][col + dc];
                        if (target && target.team !== team) {
                            moves.push({ row: row + dir, col: col + dc });
                        }
                        if (enPassantTarget && enPassantTarget.row === row + dir && enPassantTarget.col === col + dc) {
                            moves.push({ row: row + dir, col: col + dc, isEnPassant: true });
                        }
                    }
                });
                break;
            case 'knight':
                [[ -2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => addMove(row + dr, col + dc));
                break;
            case 'rook': addSlidingMoves([[-1, 0], [1, 0], [0, -1], [0, 1]]); break;
            case 'bishop': addSlidingMoves([[-1, -1], [-1, 1], [1, -1], [1, 1]]); break;
            case 'queen': addSlidingMoves([[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]); break;
            case 'king':
                [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]].forEach(([dr, dc]) => addMove(row + dr, col + dc));
                if (!piece.hasMoved && !isSquareAttacked(row, col, getOpponent(team))) {
                    const kingsideRook = boardState[row][7];
                    if (kingsideRook?.type === 'rook' && !kingsideRook.hasMoved && !boardState[row][5] && !boardState[row][6] && !isSquareAttacked(row, 5, getOpponent(team)) && !isSquareAttacked(row, 6, getOpponent(team))) {
                        moves.push({ row: row, col: 6, isCastle: true });
                    }
                    const queensideRook = boardState[row][0];
                    if (queensideRook?.type === 'rook' && !queensideRook.hasMoved && !boardState[row][1] && !boardState[row][2] && !boardState[row][3] && !isSquareAttacked(row, 2, getOpponent(team)) && !isSquareAttacked(row, 3, getOpponent(team))) {
                        moves.push({ row: row, col: 2, isCastle: true });
                    }
                }
                break;
        }
        return moves;
    }
    
    // --- FIX: Replaced the recursive isSquareAttacked function ---
    function isSquareAttacked(row, col, attackerTeam) {
        // Check for pawn attacks
        const pawnDir = attackerTeam === TEAMS.W ? 1 : -1;
        const pawnRow = row + pawnDir;
        if (pawnRow >= 0 && pawnRow < 8) {
            const p1 = boardState[pawnRow][col - 1];
            const p2 = boardState[pawnRow][col + 1];
            if (p1 && p1.team === attackerTeam && p1.type === 'pawn') return true;
            if (p2 && p2.team === attackerTeam && p2.type === 'pawn') return true;
        }

        // Check for knight attacks
        const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
        for (const [dr, dc] of knightMoves) {
            const piece = boardState[row + dr]?.[col + dc];
            if (piece && piece.team === attackerTeam && piece.type === 'knight') return true;
        }

        // Check for sliding attacks (Rook, Bishop, Queen)
        const slidingDirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
        for (const [dr, dc] of slidingDirections) {
            let r = row + dr;
            let c = col + dc;
            while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                const piece = boardState[r][c];
                if (piece) {
                    if (piece.team === attackerTeam) {
                        const isRook = piece.type === 'rook' || piece.type === 'queen';
                        const isBishop = piece.type === 'bishop' || piece.type === 'queen';
                        const isRookDirection = dr === 0 || dc === 0;
                        const isBishopDirection = dr !== 0 && dc !== 0;
                        if ((isRook && isRookDirection) || (isBishop && isBishopDirection)) return true;
                    }
                    break;
                }
                r += dr;
                c += dc;
            }
        }

        // Check for king attacks
        const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
        for (const [dr, dc] of kingMoves) {
            const piece = boardState[row + dr]?.[col + dc];
            if (piece && piece.team === attackerTeam && piece.type === 'king') return true;
        }

        return false;
    }

    function getAllLegalMoves(team) {
        const allMoves = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = boardState[r][c];
                if (piece && piece.team === team) {
                    allMoves.push(...getLegalMoves(piece));
                }
            }
        }
        return allMoves;
    }
    
    function checkGameState() {
        const allMoves = getAllLegalMoves(currentPlayer);
        const king = findKing(currentPlayer);
        if (!king) return; // Game already over if king is captured
        const isInCheck = isSquareAttacked(king.row, king.col, getOpponent(currentPlayer));

        if (allMoves.length === 0) {
            isGameOver = true;
            if (isInCheck) {
                endGame(`Checkmate! ${getOpponent(currentPlayer) === 'white' ? "White" : "Black"} team wins!`);
            } else {
                endGame("Stalemate! It's a draw!");
            }
        }
    }

    function endGame(message) {
        gameInfoElement.textContent = message;
        gameOverMessage.textContent = message;
        gameOverModal.classList.remove('hidden');
        isGameOver = true;
        updateUndoButton();
    }
    
    function resetGame() {
        initializeBoard();
        currentPlayer = TEAMS.W;
        deselectPiece();
        renderBoard();
        updatePlayerInfo();
        gameOverModal.classList.add('hidden');
    }
    
    function findKing(team) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = boardState[r][c];
                if (piece && piece.type === 'king' && piece.team === team) {
                    return piece;
                }
            }
        }
        return null;
    }

    function getOpponent(team) {
        return team === TEAMS.W ? TEAMS.B : TEAMS.W;
    }

    // --- EVENT LISTENERS ---
    startGameButton.addEventListener('click', () => {
        startModal.classList.add('hidden');
        startMusic();
    });
    musicToggleButton.addEventListener('click', toggleMusic);
    resetButton.addEventListener('click', resetGame);
    undoButton.addEventListener('click', undoMove);
    playAgainButton.addEventListener('click', resetGame);

    // --- INITIAL GAME START ---
    initializeBoard();
    renderBoard();
    updatePlayerInfo();

</script>
</body>
</html>
